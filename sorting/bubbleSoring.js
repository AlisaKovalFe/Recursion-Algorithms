// на стр. 6 при i = 0 на последней итерации 3 нужно сравнить с arr.length - 0, то есть с элементом, которого не существует, почему скрипт не падает? И зачем вообще i вычиать, без него тоже работает


const bubbleSorting = (arr) => {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i; j++) {
            // console.log(arr[j], arr[j + 1]);
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
            console.log(arr);
        }
    }
    return arr
}

console.log(bubbleSorting([1, 5, 11, 4]));



// пузырьковая сортировка устойчива, временная сложность в худшем случай O(n²). Это означает, что для массива с n элементами нужно совершить n2 операций. Т.е., в худжешм случае для каждого из элементов приходится сделать проход по всем остальным элементам массива. В лучшем случае, если массив уже отсортирован, потребуется всего n операций.

//Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется перестановка элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован.

// При каждом проходе алгоритма по внутреннему циклу очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим наибольшим элементом («всплывает» до нужной позиции, как пузырёк в воде), а наименьший элемент перемещается на одну позицию к началу массива.

// Достаточно медленный алгоритм, поэтому сортировка пузырьком — крайне неэффективный алгоритм.
// Cложность алгоритма по памяти будет константной и записывается как O(1) (сортируем уже имеющийся массив и не создаём дополнительных структур данных).




